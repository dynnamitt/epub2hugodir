#!/bin/bash

#  uncomment below to trace 
#  set -x

# -------------------------------
# CONSTS
# -------------------------------
EP_CONT=META-INF/container.xml
HUGO_CONF=config.toml

DEF_XPATH_DRAFT=
DEF_CONTENT_DIRNAME=_content
DEF_PUBLIC_DIRNAME=_public


# ------------------------
# func: help then exit
#
#  usage "error-text"
# ------------------------
usage() {
  echo
  echo Usage:
  echo "  $0 [flags] epubfile [destdir]"
  echo
  echo "  epubfile can be either epub-file OR extracted directory"
  echo "  destdir default is basedir/root of epubfile"
  echo
  echo Flags:
  echo "  -d string     Xpath marking content chunk as draft. Default empty"
  echo "  -c string     Contentdir name. Default is '_content'"

  echo
  echo "!! Error: '$1'"
  exit 1

}

# --------------------------------
# func: exit unless command found
#  
#  have_cmd cmd
# --------------------------------
have_cmd(){
  command -v $1 >/dev/null 2>&1 || {
    echo >&2
    echo >&2 " - I require [$1] but it's not installed."
    echo >&2 "   Aborting."
    exit 1; }
}

# ------------------------------
# func: exit unless path found
#
#  exist_or_die filepath
# ------------------------------
exist_or_die(){
  stat "$1" >/dev/null 2>&1 || {
    echo >&2 "File not found; '$1'"
    exit 1; } 
}

# ----------------------------------
# func: print warning unless path found
#
#  path_chk_warn filepath
# ----------------------------------
path_chk_warn(){
  stat "$1" >/dev/null 2>&1 || {
    echo >&2 "- Warning , path not found; '$1'"; }
}

# ------------------------------------------------
# func: wrap args in xslt-doc
#
#  xsl_doc method "xslt-expr" "xslt-expr2" "xslt-expr3" 
# ------------------------------------------------
xsl_doc(){
  _method=$1
  _xh_ns='http://www.w3.org/1999/xhtml'
  _indent='indent="yes"'

  if test "$_method" = "text"; then
    _omit_decl=yes
    _indent='indent="no"'
  elif test "$_method" = "xhtml"; then
    _omit_decl=yes
    _def_ns="xmlns=\"$_xh_ns\""
    _method=xml
  else
    _omit_decl=no
  fi
  shift
  cat << _EOF
<xsl:stylesheet version="1.0" $_def_ns
 xmlns:xh="$_xh_ns"
 xmlns:cont="urn:oasis:names:tc:opendocument:xmlns:container"
 xmlns:ncx="http://www.daisy.org/z3986/2005/ncx/"
 xmlns:opf="http://www.idpf.org/2007/opf"
 xmlns:strings="http://exslt.org/strings"
 xmlns:epub="http://www.idpf.org/2007/ops"
 xmlns:epvoc="http://idpf.org/epub/vocab/structure/"
 xmlns:dsct="http://readin.no/epub/custom-type/#"
 xmlns:z3998="http://www.daisy.org/z3998/2012/vocab/structure/#"
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
 exclude-result-prefixes="ncx strings cont opf epub dsct z3998 epvoc">
 <xsl:output method="$_method" encoding="utf-8" 
    omit-xml-declaration="$_omit_decl" $_indent/>
$@
</xsl:stylesheet>
_EOF
}
export -f xsl_doc # bashism !!

# ----------------------------------
# func: helper xslt grunt
#
# xsl local-xslt-func input-xml
# ----------------------------------
xsl(){
  _xsl_tmp=$(mktemp /tmp/ep2hugo_XXXXXX.xsl)
  _xsl_func=$1
  $_xsl_func > "$_xsl_tmp"
  xsltproc --novalid "$_xsl_tmp" "$2"
}
export -f xsl # bashism !!

# -------------------------------------------------------
# func: wrap args in xslt:templ-tag
#
#  xsl_templ "match-expr" "xslt-expr1" "xslt-expr2" .. 
# -------------------------------------------------------
xsl_templ(){
  _MATCH=$1
  shift
  _EXPRS=$@
  printf "<xsl:template match=\"${_MATCH}\">"
  printf "${_EXPRS}</xsl:template>"
}
export -f xsl_templ # bashism !!

# -----------------------------------
# func: usefull xsl_templ everywhere
# -----------------------------------
copy_templ(){
  xsl_templ "node()|@*" \
    "<xsl:copy>" \
    "<xsl:apply-templates select=\"@*|node()\"/>" \
    "</xsl:copy>"
}
export -f copy_templ # bashism !!

# -------------------------------------------------
# func: xslt that find epub-package path
#
#  inputdoc == oasis/container
#  output string
# -------------------------------------------------
_rootfile_path(){
  # first template is GRUNT to avoid 2 newlines
  xsl_doc text $(xsl_templ "/cont:container" \
    "<xsl:apply-templates select=\"//cont:rootfile\" />") \
    $(xsl_templ "//cont:rootfile[@media-type='application/oebps-package+xml']" \
    "<xsl:value-of select=\"@full-path\"/>" )
}

# ---------------------------------------------
# func: xslt that find ncx href (if in OPF)
#
#   inputdoc = 'package' aka 'opf' aka 'rootfile'
#   output string
# -------------------------------------------------
_ncx_href(){
  # first template is GRUNT to avoid 2 newlines
  xsl_doc text $(xsl_templ "/" \
    "<xsl:apply-templates select=\"//opf:item\" />") \
    $(xsl_templ "//opf:item[@media-type='application/x-dtbncx+xml']" \
    "<xsl:value-of select=\"@href\"/>" )
}

# ---------------------------------------------
# func: xslt that find ep3-xh-toc href
#
#   inputdoc = 'package' aka 'opf' aka 'rootfile'
#   output string
# -------------------------------------------------
_toc_href(){
  # first template is GRUNT to avoid 2 newlines
  xsl_doc text $(xsl_templ "/" \
    "<xsl:apply-templates select=\"//opf:item\" />") \
    $(xsl_templ "//opf:item[@properties='nav']" \
    "<xsl:value-of select=\"@href\"/>" )
}

# --------------------------------------------------
# func: default names-map xslt, not used if -r set
# HUGO will not RECOGNIZE .xhtm* ext.. so adjust to .htm*
#
#  inputdoc == package/opf
#  output text
# --------------------------------------------------
_xhtml_hrefs(){
  xsl_doc text $(xsl_templ "/opf:package" \
    "<xsl:apply-templates select=\"//opf:item\"/>" ) \
    $(xsl_templ "opf:item[@media-type='application/xhtml+xml']" \
    "<xsl:value-of select=\"@href\"/><xsl:text>&#xA;</xsl:text>" )
 }

# ---------------------------------------------
# func: move ep3::attr into class as extra val
#
#   inputdoc == xhtml5+epub3
#   output xhtml5(no epub3)
# --------------------------------------------
_clean_ep_type(){
  _sep=+
  xsl_doc xhtml $(copy_templ) \
    $(xsl_templ "@epub:prefix") \
    $(xsl_templ "*[@epub:type]" \
      "<xsl:variable name=\"types-cnt\" " \
      " select=\"count(strings:split(@epub:type, ' '))\" />" \
      "<xsl:copy>" \
      " <xsl:apply-templates " \
      "   select=\"@*[local-name(.) != 'type' and name(.) != 'class']\"/>" \
      "   <xsl:attribute name=\"class\">" \
      "     <xsl:if test=\"@class\">" \
      "       <xsl:value-of select=\"@class\"/>" \
      "       <xsl:text> </xsl:text>" \
      "     </xsl:if>" \
      "     <xsl:for-each select=\"strings:split(@epub:type, ' ')\">" \
      "       <xsl:value-of " \
      "        select=\"concat('et','$_sep',strings:replace(.,':','$_sep'))\"/>" \
      "       <xsl:if test=\"not(position() = \$types-cnt)\">" \
      "         <xsl:text> </xsl:text>" \
      "       </xsl:if>" \
      "     </xsl:for-each>" \
      "   </xsl:attribute>" \
      " <xsl:apply-templates " \
      "  select=\"node() | processing-instruction()\"/>" \
      "</xsl:copy>" )
}
export -f _clean_ep_type # bashism !!

# ----------------------------------
# func: gets rid of html+body elems
#   (and PI's just for the hekl)
#
#  inputdoc == xhtml5
#  output xhtml5
# -----------------------------------
_just_body(){
  xsl_doc xhtml $(xsl_templ "/" \
    "<xsl:apply-templates select=\"/xh:html/xh:body/*\" />" ) \
    $(xsl_templ "processing-instruction()") \
    $(copy_templ) 
}
export -f _just_body #bashism !!

# --------------------------------
# func: yaml of xh head metadata
#
#   inputdoc == xhtml5
#   output yaml (text)
# --------------------------------
_just_head_meta(){
  xsl_doc text $(xsl_templ "/" \
    "<xsl:apply-templates select=\"/xh:html/xh:head/*\" />" ) \
    $(xsl_templ "xh:title" \
      "<xsl:text>title : \"</xsl:text>" \
      "<xsl:value-of select=\".\" />" \
      "<xsl:text>\"</xsl:text>" ) \
    $(xsl_templ "xh:meta[@content]" \
      "<xsl:value-of select=\"@name\"/>" \
      "<xsl:text> : \"</xsl:text>" \
      "<xsl:value-of select=\"@content\" />" \
      "<xsl:text>\"</xsl:text>" )
}
export -f _just_head_meta # bashism !!

# =============================================
#                         _       
#         _ __ ___   __ _(_)_ __  
#        | '_ ` _ \ / _` | | '_ \ 
#        | | | | | | (_| | | | | |
#        |_| |_| |_|\__,_|_|_| |_|
# 

set -e # DIE fast 

# ----------------------
# commands validation
# ----------------------
printf "* Checking availiable COMMANDs in system..."
have_cmd getopts
have_cmd grep
have_cmd stat
have_cmd readlink
have_cmd xsltproc
have_cmd parallel
echo "ok"

# -----------------------------
# collect args if any
# -----------------------------

# ---------------------
# args, Input+Output
# ---------------------
EPUB=$1
test -z "$EPUB" && usage "epubfile empty"

HUGO_DIR=${2:-$(dirname "$EPUB")}
test -z "$HUGO_DIR" && usage "destdir empty"

CONTENT_DIRNAME=${DEF_CONTENT_DIRNAME}

# ---------------------------
# is DEST = SRC ? just warn
# ---------------------------
ep_dir=$(readlink -f $(dirname $EPUB))
if test "$ep_dir" = $(readlink -f "$HUGO_DIR")
then 
  echo >&2 "! NB, destdir same as EPUB location"
fi

# -----------------------------------
# Check input variant (file or dir)
# -----------------------------------
if test -d "$EPUB"; then
  printf "* Epubfile is assumed to be extracted-dir..."
  exist_or_die "$EPUB/$EP_CONT"
  echo "ok"
  EPUB_SRC=$EPUB
else
  echo "* Epubfile will be unzipped."
  exist_or_die "$EPUB"
  have_cmd unzip
  printf "* Unzipping to"
  _tmp_dir_unzip=$(mktemp --directory /tmp/epub_dir_XXXXXX)
  printf " tempdir '$_tmp_dir_unzip'..."
  unzip -q "$EPUB" -d "$_tmp_dir_unzip"
  exist_or_die "$_tmp_dir_unzip/$EP_CONT"
  echo "ok"
  EPUB_SRC=$_tmp_dir_unzip
fi


# -----------------------------------
# Move+transform content into destdir
# -----------------------------------
path_chk_warn $HUGO_DIR

CONTENT_DIR=$HUGO_DIR/$CONTENT_DIRNAME
mkdir -p $CONTENT_DIR

EP_OPF_PATH=$(xsl _rootfile_path "$EPUB_SRC/$EP_CONT")
EP_ROOT_DIR=$(dirname "$EP_OPF_PATH")
echo "* Packagefile rel path is '$EP_OPF_PATH'"

# -------------------------------
#  locate TOC xml-doc(s)
# -------------------------------
EP_NCX_HREF=$(xsl _ncx_href "$EPUB_SRC/$EP_OPF_PATH")

if test -z "$EP_NCX_HREF"; then
  printf "! NCX not found, searching for xhtml-toc..."
  EP_XHTOC_HREF=$(xsl _toc_href "$EPUB_SRC/$EP_OPF_PATH")
  if test -z "$EP_XHTOC_HREF"; then
    echo "NOT FOUND, aborting!"
    exit 1
  else
    EP_XHTOC_PATH=$EP_ROOT_DIR/$EP_XHTOC_HREF
    echo " '$EP_XHTOC_PATH'"
    echo "- making NCX..."
    echo "    NOT IMPL!"
    exit 1
  fi
else
  EP_NCX_PATH=$EP_ROOT_DIR/$EP_NCX_HREF
  echo "* NCX rel path is '$EP_NCX_PATH'"
fi

# config.toml
printf "* Writing '$HUGO_DIR/$HUGO_CONF'..."
cat << _EOF > "$HUGO_DIR/$HUGO_CONF"
contentdir = "$CONTENT_DIRNAME"
_EOF
echo "ok"

# ------------------
# func: frontmatter
# ------------------
frontmatter(){
  echo "---"
  xsl _just_head_meta "$1"
  # TODO fetch also from TOC/NCX
  # TODO bc, prev, next
  echo
  echo "---"
}
export -f frontmatter

# -----------------------------------------
# func: pipeline for each content dest
# -----------------------------------------
export _src=$EPUB_SRC/$EP_ROOT_DIR
export _dest=$HUGO_DIR/$CONTENT_DIRNAME
xhtml_pipe(){
  printf " >∙>∙ '$1' ..."
  xsl _clean_ep_type "$_src/$1" \
    | xsl _just_body /dev/stdin \
    | ( frontmatter "$_src/$1" ; cat /dev/stdin ) \
    > "$_dest/$1"
  echo ok
}
export -f xhtml_pipe # bashism !!

echo "* Concurrent mapping of content file(s)..."
xsl _xhtml_hrefs "$EPUB_SRC/$EP_OPF_PATH" \
  | parallel --no-notice xhtml_pipe {}
